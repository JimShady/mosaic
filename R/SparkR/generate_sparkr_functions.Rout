
R version 4.1.3 (2022-03-10) -- "One Push-Up"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin20.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> parser <- function(x){
+   #split on left bracket to get name
+   splitted = strsplit(x, "(", fixed=T)[[1]]
+   # extract function name
+   function_name = splitted[1]
+   # remove the trailing bracket
+   args = gsub( ")", '',splitted[2], fixed=T)
+   args = strsplit(args, ", ", fixed=T)[[1]]
+   args = lapply(args, function(x){strsplit(x, ": ", fixed=T)}[[1]])
+   output = list(
+     "function_name" = function_name
+     ,"args"=args
+   )
+   output
+ }
> 
> ############################################################
> build_generic <- function(input){
+   function_name = input$function_name
+   args = lapply(input$args, function(x){x[1]})
+   paste0(
+     'setGeneric(
+         name="',function_name,'"
+             ,def=function(',paste0(args, collapse=','), ')  {standardGeneric("',function_name, '")}
+               )
+                   ')
+ }
> ############################################################
> build_column_specifiers <- function(input){
+   args = lapply(input$args, function(x){x[1]})
+   build_column_specifier <- function(arg){ 
+     return(paste0(arg, '@jc'))
+   }
+   
+   if (length(args) > 1){
+     specs <- paste0(unlist(lapply(args, build_column_specifier)), collapse = ", ")
+     return(specs)
+   }
+   else return( build_column_specifier(args))
+ }
> ############################################################
> build_method<-function(input){
+   function_name = input$function_name
+   arg_names = lapply(input$args, function(x){c(x[1])})
+   #this handles converting non-Column arguments to their R equivalents
+   argument_parser <- function(x){
+     if(x[2] == 'Int'){
+       x[2] = "numeric"
+     }
+     else if(x[2] == 'String'){
+       x[2] = "character"
+     }
+     x
+   }
+   args = lapply(input$args, argument_parser)
+   args = lapply(args, function(x){c(x[1], paste0("'", x[2], "'"))})
+   args = lapply(args, function(x){paste0(x,  collapse= ' = ')})
+   column_specifiers <- build_column_specifiers(input)
+   paste0(
+     'setMethod(
+               f = "',function_name, '"
+               ,signature(
+                    ',paste0(args, collapse = "\n                   ,"),
+     '
+                 )
+               ,function(', paste0(arg_names, collapse= ','), ') {
+                   jc <- sparkR.callJMethod(functions, "', function_name,'", ', column_specifiers, ' )
+                   column(jc)
+                   }
+               )')
+   
+ }
> ############################################################
> 
> ############################################################
> get_function_names <- function(scala_file_path){
+   #scala_file = file("~/Documents/mosaic/src/main/scala/com/databricks/labs/mosaic/functions/MosaicContext.scala")
+   scala_file = file(scala_file_path)
+   
+   scala_file = readLines(scala_file)
+   closeAllConnections()
+   # find where the methods start
+   start_string = "    object functions extends Serializable {"
+   start_index = grep(start_string, scala_file, fixed=T) + 1
+   # find the methods end - will be the next curly bracket
+   for(i in start_index : length(scala_file)){
+     if(grepl("}", scala_file[i], fixed=T)){
+       break
+     }
+   }
+   methods_to_bind = scala_file[start_index:i]
+   # remove any line that doesn't start with def
+   def_mask = grepl("def ", methods_to_bind, fixed = T)
+   methods_to_bind = methods_to_bind[def_mask]
+   # parse the string to get just the function_name(input:type...) pattern
+   methods_to_bind = unlist(lapply(methods_to_bind, function(x){
+     substr(x
+            , regexpr("def ", x, fixed=T)[1]+4 # get the starting point to account for whitespace
+            , regexpr("): ", x, fixed=T)[1] # get the end point of where the return is.
+            )
+     }
+     ))
+   methods_to_bind
+ }
> 
> ########################################################################
> main <- function(){
+   # this assumes working directoy is the SparkR folder
+   scala_file_path="../../src/main/scala/com/databricks/labs/mosaic/functions/MosaicContext.scala"
+   function_data = get_function_names(scala_file_path)
+ 
+   genericFileConn = file("generics.R")
+   methodsFileConn = file("functions.R")
+   
+   generics <- lapply(function_data, function(x){build_generic(parser(x))})
+   methods <- lapply(function_data, function(x){build_method(parser(x))})
+   writeLines(paste0(generics, collapse="\n"), genericFileConn)
+   writeLines(paste0(methods, collapse="\n"), methodsFileConn)
+   closeAllConnections()
+   
+   package.skeleton(
+     name="sparkrMosaic"
+     ,code_files=c("generics.R", "functions.R")
+   )
+ }
> 
> if (sys.nframe() == 0){
+   main()
+ }
in method for ‘as_hex’ with signature ‘inGeom="Column"’: no definition for class “Column”
in method for ‘as_json’ with signature ‘inGeom="Column"’: no definition for class “Column”
in method for ‘st_point’ with signature ‘xVal="Column",yVal="Column"’: no definition for class “Column”
in method for ‘st_makeline’ with signature ‘points="Column"’: no definition for class “Column”
in method for ‘st_makepolygon’ with signature ‘boundaryRing="Column"’: no definition for class “Column”
in method for ‘st_makepolygon’ with signature ‘boundaryRing="Column",holeRingArray="Column"’: no definition for class “Column”
in method for ‘flatten_polygons’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_xmax’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_xmin’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_ymax’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_ymin’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_zmax’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_zmin’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_isvalid’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_geometrytype’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_area’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_centroid2D’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_centroid3D’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘convert_to’ with signature ‘inGeom="Column",outDataType="character"’: no definition for class “Column”
in method for ‘st_geomfromwkt’ with signature ‘inGeom="Column"’: no definition for class “Column”
in method for ‘st_geomfromwkb’ with signature ‘inGeom="Column"’: no definition for class “Column”
in method for ‘st_geomfromgeojson’ with signature ‘inGeom="Column"’: no definition for class “Column”
in method for ‘st_aswkt’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_astext’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_aswkb’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_asbinary’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_asgeojson’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_dump’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_length’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_perimeter’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_distance’ with signature ‘geom1="Column",geom2="Column"’: no definition for class “Column”
in method for ‘st_contains’ with signature ‘geom1="Column",geom2="Column"’: no definition for class “Column”
in method for ‘st_translate’ with signature ‘geom1="Column",xd="Column",yd="Column"’: no definition for class “Column”
in method for ‘st_scale’ with signature ‘geom1="Column",xd="Column",yd="Column"’: no definition for class “Column”
in method for ‘st_rotate’ with signature ‘geom1="Column",td="Column"’: no definition for class “Column”
in method for ‘st_convexhull’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_numpoints’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_intersects’ with signature ‘left="Column",right="Column"’: no definition for class “Column”
in method for ‘st_intersection’ with signature ‘left="Column",right="Column"’: no definition for class “Column”
in method for ‘st_srid’ with signature ‘geom="Column"’: no definition for class “Column”
in method for ‘st_setsrid’ with signature ‘geom="Column",srid="Column"’: no definition for class “Column”
in method for ‘st_transform’ with signature ‘geom="Column",srid="Column"’: no definition for class “Column”
in method for ‘st_intersects_aggregate’ with signature ‘leftIndex="Column",rightIndex="Column"’: no definition for class “Column”
in method for ‘st_intersection_aggregate’ with signature ‘leftIndex="Column",rightIndex="Column"’: no definition for class “Column”
in method for ‘mosaic_explode’ with signature ‘geom="Column",resolution="Column"’: no definition for class “Column”
in method for ‘mosaic_explode’ with signature ‘geom="Column",resolution="numeric"’: no definition for class “Column”
in method for ‘mosaicfill’ with signature ‘geom="Column",resolution="Column"’: no definition for class “Column”
in method for ‘mosaicfill’ with signature ‘geom="Column",resolution="numeric"’: no definition for class “Column”
in method for ‘point_index_geom’ with signature ‘point="Column",resolution="Column"’: no definition for class “Column”
in method for ‘point_index_geom’ with signature ‘point="Column",resolution="numeric"’: no definition for class “Column”
in method for ‘point_index_lonlat’ with signature ‘lon="Column",lat="Column",resolution="Column"’: no definition for class “Column”
in method for ‘point_index_lonlat’ with signature ‘lon="Column",lat="Column",resolution="numeric"’: no definition for class “Column”
in method for ‘polyfill’ with signature ‘geom="Column",resolution="Column"’: no definition for class “Column”
in method for ‘polyfill’ with signature ‘geom="Column",resolution="numeric"’: no definition for class “Column”
in method for ‘index_geometry’ with signature ‘indexID="Column"’: no definition for class “Column”
in method for ‘try_sql’ with signature ‘inCol="Column"’: no definition for class “Column”
Creating directories ...
Creating DESCRIPTION ...
Creating NAMESPACE ...
Creating Read-and-delete-me ...
Copying code files ...
Making help files ...
Done.
Further steps are described in './sparkrMosaic/Read-and-delete-me'.
Warning message:
In .Internal(gc(verbose, reset, full)) :
  closing unused connection 3 (../../src/main/scala/com/databricks/labs/mosaic/functions/MosaicContext.scala)
> 
> proc.time()
   user  system elapsed 
  0.417   0.135   0.591 
